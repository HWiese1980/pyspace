<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pySPACE.missions.nodes.templates &mdash; pySPACE documentation</title>
    
    <link rel="stylesheet" href="../../../../_static/pySPACE.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '1.3 release',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../../../_static/pyspace-logo.ico"/>
    <link rel="top" title="pySPACE documentation" href="../../../../index.html" />
    <link rel="up" title="Module code" href="../../../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">pySPACE documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../../index.html">
              <img class="logo" src="../../../../_static/pyspace-logo_small.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pySPACE.missions.nodes.templates</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot; Tell the developer about general coding and documentation approaches for nodes</span>

<span class="sd">A very useful tutorial can be found under :ref:`t_new_node`.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">pySPACE.missions.nodes.base_node</span> <span class="kn">import</span> <span class="n">BaseNode</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">pySPACE.resources.data_types.feature_vector</span> <span class="kn">import</span> <span class="n">FeatureVector</span>
<span class="kn">from</span> <span class="nn">pySPACE.tools.memoize_generator</span> <span class="kn">import</span> <span class="n">MemoizeGenerator</span>

<div class="viewcode-block" id="SimpleDataTransformationTemplateNode"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.SimpleDataTransformationTemplateNode">[docs]</a><span class="k">class</span> <span class="nc">SimpleDataTransformationTemplateNode</span><span class="p">(</span><span class="n">BaseNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Parametrized algorithm, transforming the data without training</span>

<span class="sd">    Describe your algorithm in detail.</span>

<span class="sd">    In the simplest case, an algorithm only implements its initialization</span>
<span class="sd">    and execution function like this node.</span>

<span class="sd">    The list of parameters should always be complete and correct to avoid</span>
<span class="sd">    hidden functionality.</span>

<span class="sd">    **References**</span>

<span class="sd">        If this node is using code from other implementations or</span>
<span class="sd">        is described in detail in a publication,</span>
<span class="sd">        mention the reference here.</span>

<span class="sd">    **Parameters**</span>
<span class="sd">        :Parameter1: Describe effect and specialties</span>

<span class="sd">            (*recommended, default: 42*)</span>

<span class="sd">        :Parameter2: Describe the effect, and if something special happens by</span>
<span class="sd">            default. It is also important to mention, which entries are possible</span>
<span class="sd">            (e.g. only True and False are accepted values).</span>

<span class="sd">            (*optional, default: False*)</span>

<span class="sd">    **Exemplary Call**</span>

<span class="sd">    .. code-block:: yaml</span>

<span class="sd">        -</span>
<span class="sd">            node : SimpleDataTransformationTemplate</span>
<span class="sd">            parameters:</span>
<span class="sd">                Parameter1 : 77</span>
<span class="sd">                Parameter2 : False</span>


<span class="sd">    :input:    Type1 (e.g. FeatureVector)</span>
<span class="sd">    :output:   Type2 (e.g. FeatureVector)</span>
<span class="sd">    :Author: Mario Muster (muster@informatik.exelent-university.de)</span>
<span class="sd">    :Created: 2013/02/25</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="SimpleDataTransformationTemplateNode.__init__"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.SimpleDataTransformationTemplateNode.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Parameter1</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span> <span class="n">Parameter2</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Set the basic parameters special for this algorithm</span>

<span class="sd">        If your init is not doing anything special, it does not need any</span>
<span class="sd">        documentation. The relevant class documentation</span>
<span class="sd">        is expected to be in the class docstring.</span>

<span class="sd">        .. note::</span>
<span class="sd">            The mapping from the call of the function with a YAML file</span>
<span class="sd">            and this init is totally straightforward.</span>
<span class="sd">            Every parameter in the dictionary description in the</span>
<span class="sd">            YAML file is directly used at the init call.</span>
<span class="sd">            The value of the parameter is transformed with the help</span>
<span class="sd">            of the YAML syntax (see: :ref:`yaml`).</span>

<span class="sd">        It is important to also use `**kwargs`, because they have to be</span>
<span class="sd">        forwarded to the base class, using:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            super(SimpleDataTransformationTemplateNode, self).__init__(**kwargs)</span>

<span class="sd">        .. warning::</span>
<span class="sd">            With the call of `super` comes some hidden functionality.</span>
<span class="sd">            Every self parameter in the init is made permanent via the</span>
<span class="sd">            function:</span>
<span class="sd">            :func:`~pySPACE.missions.nodes.base_node.BaseNode.set_permanent_attributes`</span>
<span class="sd">            from the base node.</span>
<span class="sd">            Normally all self parameters are instantiated after this call</span>
<span class="sd">            and have to be made permanent on their own.</span>
<span class="sd">            Permanent means, that these parameters are reset to the</span>
<span class="sd">            defined value, when the</span>
<span class="sd">            :func:`~pySPACE.missions.nodes.base_node.BaseNode.reset`</span>
<span class="sd">            method is called.</span>
<span class="sd">            This is for example done during k-fold cross validation, when</span>
<span class="sd">            the training fold is changed.</span>
<span class="sd">            For special variable types you may run into trouble,</span>
<span class="sd">            because set_permanent_attributes needs to copy them.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            The init function is called before the distribution of node_chains</span>
<span class="sd">            in the parallel execution. So the node parameters need to be</span>
<span class="sd">            able to be stored into the pickle format.</span>
<span class="sd">            If you need parameters, which have not this functionality,</span>
<span class="sd">            just initialize them with the first call of the training or execute</span>
<span class="sd">            method.</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            self.set_permanent_attributes(  P1 : Parameter1,</span>
<span class="sd">                                            P2 : Parameter2,</span>
<span class="sd">                                            P3 : &quot;Hello&quot;</span>
<span class="sd">                                         )</span>

<span class="sd">        Here `self.P3` will be an internal parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SimpleDataTransformationTemplateNode</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">Parameter1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Parameter 1 is having wrong type </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span>
                <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">Parameter1</span><span class="p">)))</span>
            <span class="n">Parameter1</span> <span class="o">=</span> <span class="mi">42</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_permanent_attributes</span><span class="p">(</span><span class="n">P1</span><span class="o">=</span><span class="n">Parameter1</span><span class="p">,</span>
                                      <span class="n">P2</span><span class="o">=</span><span class="n">Parameter2</span><span class="p">,</span>
                                      <span class="n">P3</span><span class="o">=</span><span class="s2">&quot;Hello&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="SimpleDataTransformationTemplateNode._execute"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.SimpleDataTransformationTemplateNode._execute">[docs]</a>    <span class="k">def</span> <span class="nf">_execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; General description of algorithm maybe followed by further details</span>

<span class="sd">        E.g. log &quot;Hello&quot; during first call and if P2 is set to True,</span>
<span class="sd">        always multiply data with P1 and in the other case forward the data.</span>

<span class="sd">        Logging is done using</span>
<span class="sd">        :func:`~pySPACE.missions.nodes.base_node.BaseNode._log`:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            self._log(self.P3, level=logging.DEBUG)</span>

<span class="sd">        To access only the data array and not the attached meta data, use</span>
<span class="sd">        `data = x.view(numpy.ndarray)` for preparation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">P3</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P3</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">P3</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">P2</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">P1</span> <span class="o">*</span> <span class="n">data</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">FeatureVector</span><span class="o">.</span><span class="n">replace_data</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div></div>


<div class="viewcode-block" id="TrainableAlgorithmTemplateNode"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.TrainableAlgorithmTemplateNode">[docs]</a><span class="k">class</span> <span class="nc">TrainableAlgorithmTemplateNode</span><span class="p">(</span><span class="n">SimpleDataTransformationTemplateNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Template for trainable algorithms</span>

<span class="sd">    :class:`SimpleDataTransformationTemplateNode` is the base node for this node</span>
<span class="sd">    and so, this node does not have to implement an _execute or __init__</span>
<span class="sd">    function. Often these methods have to be implemented nevertheless,</span>
<span class="sd">    but not here, to keep the example short.</span>

<span class="sd">    For trainable methods, a minimum of two functions has to be implemented:</span>
<span class="sd">    :func:`is_trainable` and :func:`_train`.</span>
<span class="sd">    Optionally four other functions can be overwritten:</span>
<span class="sd">    :func:`is_supervised`, :func:`_stop_training`, :func:`_inc_train`</span>
<span class="sd">    and :func:`start_retraining.`</span>
<span class="sd">    The first returns by default `False` and the other methods do nothing.</span>

<span class="sd">    .. note:: The execute function is applied on all data,</span>
<span class="sd">              even the training data, but the true label remains unknown.</span>

<span class="sd">    **Parameters**</span>
<span class="sd">        Please refer to :class:`SimpleDataTransformationTemplateNode`</span>

<span class="sd">        .. note:: Parameter1 is determined, by counting the training examples.</span>

<span class="sd">    **Exemplary Call**</span>

<span class="sd">    .. code-block:: yaml</span>

<span class="sd">        -</span>
<span class="sd">            node : TrainableAlgorithmTemplateNode</span>
<span class="sd">            parameters:</span>
<span class="sd">                Parameter1 : 77</span>
<span class="sd">                Parameter2 : False</span>

<span class="sd">    :input:    Type1 (e.g. FeatureVector)</span>
<span class="sd">    :output:   Type2 (e.g. FeatureVector)</span>
<span class="sd">    :Author: Mario Muster (muster@informatik.exelent-university.de)</span>
<span class="sd">    :Created: 2013/02/25</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="TrainableAlgorithmTemplateNode.is_trainable"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.TrainableAlgorithmTemplateNode.is_trainable">[docs]</a>    <span class="k">def</span> <span class="nf">is_trainable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Define trainable node, by returning True in this function &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">True</span></div>

<div class="viewcode-block" id="TrainableAlgorithmTemplateNode.is_supervised"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.TrainableAlgorithmTemplateNode.is_supervised">[docs]</a>    <span class="k">def</span> <span class="nf">is_supervised</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return True to get access to labels in training functions &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">True</span></div>

<div class="viewcode-block" id="TrainableAlgorithmTemplateNode._train"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.TrainableAlgorithmTemplateNode._train">[docs]</a>    <span class="k">def</span> <span class="nf">_train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="n">class_label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Called for each element in training data to be processed</span>

<span class="sd">        Incremental algorithms, simply use the example to change their</span>
<span class="sd">        parameters and batch algorithms preprocess data and only store it.</span>

<span class="sd">        If :func:`is_supervised` were not overwritten or set `False`,</span>
<span class="sd">        this function is defined without the parameter *class_label*</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">P3</span> <span class="o">==</span> <span class="s2">&quot;Hello&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">P3</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">P1</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P1</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P3</span> <span class="o">+=</span> <span class="n">class_label</span></div>

<div class="viewcode-block" id="TrainableAlgorithmTemplateNode._stop_training"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.TrainableAlgorithmTemplateNode._stop_training">[docs]</a>    <span class="k">def</span> <span class="nf">_stop_training</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Called after processing of all training examples</span>

<span class="sd">        For simplicity, we just reimplement the default.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="TrainableAlgorithmTemplateNode._inc_train"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.TrainableAlgorithmTemplateNode._inc_train">[docs]</a>    <span class="k">def</span> <span class="nf">_inc_train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">data</span><span class="p">,</span> <span class="n">class_label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Train on new examples in testing phase</span>

<span class="sd">        During testing phase in the application phase,</span>
<span class="sd">        new labeled examples may occur  and this function is</span>
<span class="sd">        used to improve the already trained algorithm on these examples.</span>

<span class="sd">        .. note:: This method should always be as fast as possible.</span>

<span class="sd">        For simplicity, we only forward everything to :func:`_train`.</span>

<span class="sd">        For more details on retraining (how to turn it on, and how it works),</span>
<span class="sd">        have a look at the documentation of the *retrain* parameter</span>
<span class="sd">        in the :class:`~pySPACE.missions.nodes.base_node.BaseNode`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">class_label</span><span class="p">)</span></div>

<div class="viewcode-block" id="TrainableAlgorithmTemplateNode.start_retraining"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.TrainableAlgorithmTemplateNode.start_retraining">[docs]</a>    <span class="k">def</span> <span class="nf">start_retraining</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Prepare retraining</span>

<span class="sd">        Normally this method is not needed and does nothing,</span>
<span class="sd">        but maybe some parameters</span>
<span class="sd">        have to be changed, before the first retraining with</span>
<span class="sd">        the _inc_train method should be done.</span>
<span class="sd">        This method is here, to give this possibility.</span>

<span class="sd">        In our case, we simply reset the starting parameter *self.P3*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P3</span> <span class="o">=</span> <span class="s2">&quot;Hello&quot;</span></div></div>


<div class="viewcode-block" id="SpecialPurposeFunctionsTemplate"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.SpecialPurposeFunctionsTemplate">[docs]</a><span class="k">class</span> <span class="nc">SpecialPurposeFunctionsTemplate</span><span class="p">(</span><span class="n">BaseNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Introduce additional available functions</span>

<span class="sd">    Additional to the aforementioned methods,</span>
<span class="sd">    some algorithms have to overwrite the default behavior of nodes,</span>
<span class="sd">    directly change the normal data flow,</span>
<span class="sd">    manipulate data or labels,</span>
<span class="sd">    or communicate information to other nodes.</span>

<span class="sd">    Some of these methods will be introduced in the following and some use cases</span>
<span class="sd">    will be given.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        Every method in the :class:`~pySPACE.missions.nodes.base_node.BaseNode`</span>
<span class="sd">        could be overwritten but this should be done very carefully to avoid</span>
<span class="sd">        bad side effects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="SpecialPurposeFunctionsTemplate.store_state"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.SpecialPurposeFunctionsTemplate.store_state">[docs]</a>    <span class="k">def</span> <span class="nf">store_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result_dir</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Store some additional results or information of this node</span>

<span class="sd">        Here the parameter *self.store* should be used to switch on the saving,</span>
<span class="sd">        since this method is called in every case,</span>
<span class="sd">        but should only store information, if this parameter is set true</span>

<span class="sd">        This method is automatically called during benchmarking</span>
<span class="sd">        for every node.</span>
<span class="sd">        It is for example used</span>
<span class="sd">        to store visualization of algorithms or data.</span>

<span class="sd">        Additionally to the result_dir, the node name should be used.</span>
<span class="sd">        If you expect this node to occur multiple times in a node chain,</span>
<span class="sd">        also use the index. This can be done for example like:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            import os</span>
<span class="sd">            from pySPACE.tools.filesystem import create_directory</span>
<span class="sd">            if self.store:</span>
<span class="sd">                #set the specific directory for this particular node</span>
<span class="sd">                node_dir = os.path.join(result_dir, self.__class__.__name__)</span>
<span class="sd">                #do we have an index-number?</span>
<span class="sd">                if index is None:</span>
<span class="sd">                    #add the index-number...</span>
<span class="sd">                    node_dir += &quot;_%d&quot; % int(index)</span>
<span class="sd">                create_directory(node_dir)</span>

<span class="sd">        Furthermore, it is very important to integrate the split number into</span>
<span class="sd">        the file name when storing, because otherwise your results will be</span>
<span class="sd">        overwritten. The convention in pySPACE is, to have a meaningful name</span>
<span class="sd">        of the part of the node you store followed by an underscore and &#39;sp&#39;</span>
<span class="sd">        and the split number as done in</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            file_name = &quot;%s_sp%s.pickle&quot; % (&quot;patterns&quot;, self.current_split)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="SpecialPurposeFunctionsTemplate.reset"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.SpecialPurposeFunctionsTemplate.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Resets the node to a clean state</span>

<span class="sd">        Every parameter set with</span>
<span class="sd">        :func:`~pySPACE.missions.nodes.base_node.BaseNode.set_permanent_attributes`</span>
<span class="sd">        is by default reset here to its specified value or deleted,</span>
<span class="sd">        if no value is specified.</span>

<span class="sd">        Since this method copies every parameter or some variables escape</span>
<span class="sd">        from the normal class variables scope, some methods need to overwrite</span>
<span class="sd">        this method.</span>

<span class="sd">        When you really need to overwrite this method some points have to be</span>
<span class="sd">        considered. For the normal functionality of the node, the super method</span>
<span class="sd">        needs to be called. To avoid deleting of the special variables,</span>
<span class="sd">        they have to be made local variables beforehand and afterwards again</span>
<span class="sd">        cast to class variables. This is depicted in the following example code,</span>
<span class="sd">        taken from the</span>
<span class="sd">        :class:`~pySPACE.missions.nodes.meta.same_input_layer.SameInputLayerNode`.</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            def reset(self):</span>
<span class="sd">                &#39;&#39;&#39; Also reset internal nodes &#39;&#39;&#39;</span>
<span class="sd">                nodes = self.nodes</span>
<span class="sd">                for node in nodes:</span>
<span class="sd">                    node.reset()</span>
<span class="sd">                super(SameInputLayerNode, self).reset()</span>
<span class="sd">                self.nodes = nodes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="SpecialPurposeFunctionsTemplate.get_result_dataset"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.SpecialPurposeFunctionsTemplate.get_result_dataset">[docs]</a>    <span class="k">def</span> <span class="nf">get_result_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Implementing this function, makes a node a :mod:`~pySPACE.missions.nodes.sink` &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="SpecialPurposeFunctionsTemplate.request_data_for_training"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.SpecialPurposeFunctionsTemplate.request_data_for_training">[docs]</a>    <span class="k">def</span> <span class="nf">request_data_for_training</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_test_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns generator for training data for subsequent nodes of the node chain</span>

<span class="sd">        If *use_test_data* is true, all available data is used for</span>
<span class="sd">        training, otherwise only the data that is explicitly for training.</span>

<span class="sd">        These methods normally use the</span>
<span class="sd">        :class:`~pySPACE.tools.memoize_generator.MemoizeGenerator`</span>
<span class="sd">        to define their generator.</span>
<span class="sd">        When implementing such a method, one should always try not to double</span>
<span class="sd">        data but only redirect it, without extra storing it.</span>

<span class="sd">        The definition or redefinition of training data is done</span>
<span class="sd">        by :mod:`~pySPACE.missions.nodes.source` and</span>
<span class="sd">        :mod:`~pySPACE.missions.nodes.splitter` nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="SpecialPurposeFunctionsTemplate.request_data_for_testing"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.SpecialPurposeFunctionsTemplate.request_data_for_testing">[docs]</a>    <span class="k">def</span> <span class="nf">request_data_for_testing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns data for testing of subsequent nodes of the node chain</span>

<span class="sd">        When defining :func:`request_data_for_training` this method</span>
<span class="sd">        normally has to be</span>
<span class="sd">        implemented/overwritten, too and vice versa.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="SpecialPurposeFunctionsTemplate.process_current_split"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.SpecialPurposeFunctionsTemplate.process_current_split">[docs]</a>    <span class="k">def</span> <span class="nf">process_current_split</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Main processing part on test and training data of current split</span>

<span class="sd">        This method is called in the usage with benchmark node chains</span>
<span class="sd">        and defines the gathering of the result data of the node chain</span>
<span class="sd">        for a :mod:`~pySPACE.missions.nodes.sink` node.</span>

<span class="sd">        Hereby it gets the data by calling</span>
<span class="sd">        :func:`request_data_for_training` and :func:`request_data_for_testing`.</span>

<span class="sd">        In the case of using the</span>
<span class="sd">        :class:`~pySPACE.missions.nodes.cv_splitter.CrossValidationSplitterNode`,</span>
<span class="sd">        this method is called multiple times</span>
<span class="sd">        for each split and stores every time the result in the result dataset</span>
<span class="sd">        separately.</span>

<span class="sd">        Though this approach seems on first sight very complicated on first</span>
<span class="sd">        sight, it gives three very strong advantages.</span>

<span class="sd">        * The cross validation can be done exactly before the first trainable</span>
<span class="sd">          node in the node chain and circumvents unnecessary double processing.</span>

<span class="sd">        * By handling indices instead of real data,</span>
<span class="sd">          the data for training and testing is not copied and memory is saved.</span>

<span class="sd">        * The cross validation is very easy to use.</span>
<span class="sd">          Moving this functionality to the</span>
<span class="sd">          :mod:`~pySPACE.resources.dataset_types`</span>
<span class="sd">          would make the usage muh mor complicated and inefficient.</span>
<span class="sd">          Especially for nodes, which internally use node chains,</span>
<span class="sd">          like the :mod:`~pySPACE.missions.nodes.meta.parameter_optimization`</span>
<span class="sd">          nodes, this easy access pays off.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="SpecialPurposeFunctionsTemplate.get_sensor_ranking"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.SpecialPurposeFunctionsTemplate.get_sensor_ranking">[docs]</a>    <span class="k">def</span> <span class="nf">get_sensor_ranking</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return sensor ranking fitting to the algorithm</span>

<span class="sd">        For usage with the ranking variant in the</span>
<span class="sd">        :class:`~pySPACE.missions.nodes.spatial_filtering.sensor_selection.SensorSelectionRankingNode`</span>
<span class="sd">        this method of the node is called to get the ranking to reduce sensors.</span>

<span class="sd">        The ranking is a sorted list of tuple (sensor name, weight).</span>
<span class="sd">        The first element has to correspond to the</span>
<span class="sd">        sensor with the lowest weight, meaning it is the most unimportant.</span>

<span class="sd">        .. note:: The code here is a copy from</span>
<span class="sd">            :class:`~pySPACE.missions.nodes.classification.base`</span>
<span class="sd">            which takes the classification vector `self.features`</span>
<span class="sd">            and sums up the absolute values fitting to one channel.</span>
<span class="sd">            It is only used as an example.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># channel name is what comes after the first underscore</span>
        <span class="n">feat_channel_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">chnames</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                              <span class="k">for</span> <span class="n">chnames</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="o">.</span><span class="n">feature_names</span><span class="p">]</span>
        <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
        <span class="n">ranking_dict</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
            <span class="n">ranking_dict</span><span class="p">[</span><span class="n">feat_channel_names</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
        <span class="n">ranking</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">ranking_dict</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ranking</span></div></div>


<div class="viewcode-block" id="SimpleSourceTemplateNode"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.SimpleSourceTemplateNode">[docs]</a><span class="k">class</span> <span class="nc">SimpleSourceTemplateNode</span><span class="p">(</span><span class="n">BaseNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A simple template that illustrates the basic principles of a source node</span>

<span class="sd">    In `pySPACE`, source nodes are used at the beginning of the node chain.</span>
<span class="sd">    The source nodes are responsible for the input of data, be it from a</span>
<span class="sd">    static source or from a live stream.</span>

<span class="sd">    It is very important to note that these nodes just serve the purpose of</span>
<span class="sd">    providing the node chain with an input dataset and do not perform any</span>
<span class="sd">    changes on the data itself. That being said, these nodes are **do not**</span>
<span class="sd">    have an **input node** and are **not trainable**!</span>

<span class="sd">    In the following we will discuss the general strategy for building a new</span>
<span class="sd">    source node for a static input data set which has been saved to disk.</span>
<span class="sd">    In the case of more complicated inputs, please consult the documentation of</span>
<span class="sd">    :mod:`~pySPACE.missions.nodes.source.external_generator_source.ExternalGeneratorSourceNode`</span>
<span class="sd">    and :mod:`~pySPACE.missions.nodes.source.time_series_source.Stream2TimeSeriesSourceNode`</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="SimpleSourceTemplateNode.__init__"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.SimpleSourceTemplateNode.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Initialize some values to 0 or `None`</span>

<span class="sd">        The initialization routine of the source node is basically completely</span>
<span class="sd">        empty. Should you feel the need to do something in this part of the</span>
<span class="sd">        code, you can initialize the ``input_dataset`` to ``None``. This</span>
<span class="sd">        attribute will then later be changed when the ``set_input_dataset``</span>
<span class="sd">        method is called.</span>

<span class="sd">        If the user wants to generate the dataset inside the SourceNode,</span>
<span class="sd">        this should be done in the ``__init__`` method though. A good example</span>
<span class="sd">        of this practice can be found in the</span>
<span class="sd">        :mod:`~pySPACE.missions.nodes.source.random_time_series_source.RandomTimeSeriesSourceNode`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SimpleSourceTemplateNode</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_permanent_attributes</span><span class="p">(</span><span class="n">dataset</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span></div>

<div class="viewcode-block" id="SimpleSourceTemplateNode.set_input_dataset"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.SimpleSourceTemplateNode.set_input_dataset">[docs]</a>    <span class="k">def</span> <span class="nf">set_input_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Sets the dataset from which this node reads the data</span>

<span class="sd">        This method is the beginning of the node. Put simply, this method</span>
<span class="sd">        starts the feeding process of your node chain by telling the node chain</span>
<span class="sd">        where to get the data from.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_permanent_attributes</span><span class="p">(</span><span class="n">dataset</span><span class="o">=</span><span class="n">dataset</span><span class="p">)</span></div>

<div class="viewcode-block" id="SimpleSourceTemplateNode.request_data_for_training"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.SimpleSourceTemplateNode.request_data_for_training">[docs]</a>    <span class="k">def</span> <span class="nf">request_data_for_training</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_test_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the data that can be used for training of subsequent nodes</span>

<span class="sd">        This method streams training data and sends it to the subsequent nodes.</span>
<span class="sd">        If one looks at the tutorial related to building new nodes (available in</span>
<span class="sd">        the tutorial section), one can see exactly where the ``request_data``</span>
<span class="sd">        methods are put to use.</span>

<span class="sd">        The following example is one that was extracted from the</span>
<span class="sd">        :mod:`~pySPACE.missions.nodes.source.feature_vector_source.FeatureVectorSourceNode`</span>

<span class="sd">        which should(in theory at least) be implementable for all types of data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">use_test_data</span><span class="p">:</span>
            <span class="c1"># If the input dataset consists only of one single run,</span>
            <span class="c1"># we use this as input for all runs to be conducted (i.e. we</span>
            <span class="c1"># rely on later randomization of the order). Otherwise</span>
            <span class="c1"># we use the data for this run number</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">meta_data</span><span class="p">[</span><span class="s2">&quot;runs&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">run_number</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_split</span><span class="p">,</span> <span class="s2">&quot;train&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_split</span><span class="p">,</span> <span class="s2">&quot;train&quot;</span><span class="p">)</span>
            <span class="c1"># Check if there is training data for the current split and run</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s2">&quot;Accessing input dataset&#39;s training feature vector windows.&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data_for_training</span> <span class="o">=</span> <span class="n">MemoizeGenerator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="o">*</span><span class="n">key</span><span class="p">)</span><span class="o">.</span><span class="n">__iter__</span><span class="p">(),</span>
                                                          <span class="n">caching</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">caching</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Returns an iterator that iterates over an empty sequence</span>
                <span class="c1"># (i.e. an iterator that is immediately exhausted), since</span>
                <span class="c1"># this node does not provide any data that is explicitly</span>
                <span class="c1"># dedicated for training</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s2">&quot;No training data available.&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data_for_training</span> <span class="o">=</span> <span class="n">MemoizeGenerator</span><span class="p">((</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[]</span><span class="o">.</span><span class="n">__iter__</span><span class="p">()),</span>
                                                          <span class="n">caching</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">caching</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Return the test data as there is no additional data that</span>
            <span class="c1"># was dedicated for training</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">request_data_for_testing</span><span class="p">()</span>

        <span class="c1"># Return a fresh copy of the generator</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_for_training</span><span class="o">.</span><span class="n">fresh</span><span class="p">()</span></div>


<div class="viewcode-block" id="SimpleSourceTemplateNode.request_data_for_testing"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.SimpleSourceTemplateNode.request_data_for_testing">[docs]</a>    <span class="k">def</span> <span class="nf">request_data_for_testing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the data that can be used for testing of subsequent nodes</span>

<span class="sd">        The principle of obtaining the testing data are the same as the principles</span>
<span class="sd">        used in obtaining the training data set. The only difference here is that,</span>
<span class="sd">        in the case in which there is no testing data available, we allow for the</span>
<span class="sd">        training data to be used as testing data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If we haven&#39;t read the data for testing yet</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_for_testing</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s2">&quot;Accessing input dataset&#39;s test feature vector windows.&quot;</span><span class="p">)</span>
            <span class="c1"># If the input dataset consists only of one single run,</span>
            <span class="c1"># we use this as input for all runs to be conducted (i.e. we</span>
            <span class="c1"># rely on later randomization of the order). Otherwise</span>
            <span class="c1"># we use the data for this run number</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">meta_data</span><span class="p">[</span><span class="s2">&quot;runs&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">run_number</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_split</span><span class="p">,</span> <span class="s2">&quot;test&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_split</span><span class="p">,</span> <span class="s2">&quot;test&quot;</span><span class="p">)</span>

            <span class="n">test_data_generator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="o">*</span><span class="n">key</span><span class="p">)</span><span class="o">.</span><span class="n">__iter__</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">data_for_testing</span> <span class="o">=</span> <span class="n">MemoizeGenerator</span><span class="p">(</span><span class="n">test_data_generator</span><span class="p">,</span>
                                                     <span class="n">caching</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">caching</span><span class="p">)</span>

        <span class="c1"># Return a fresh copy of the generator</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_for_testing</span><span class="o">.</span><span class="n">fresh</span><span class="p">()</span></div>


<div class="viewcode-block" id="SimpleSourceTemplateNode.getMetadata"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.SimpleSourceTemplateNode.getMetadata">[docs]</a>    <span class="k">def</span> <span class="nf">getMetadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return the value corresponding to the given key from the dataset meta data of this source node</span>

<span class="sd">        At some point in time, you might need to know the metadata of some</span>
<span class="sd">        specific input in your input and this is when you would use this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">meta_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span></div>

<div class="viewcode-block" id="SimpleSourceTemplateNode.use_next_split"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.SimpleSourceTemplateNode.use_next_split">[docs]</a>    <span class="k">def</span> <span class="nf">use_next_split</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return False</span>

<span class="sd">        The method will always return `False` since the SourceNode</span>
<span class="sd">        should(in the case of more than 1 split) execute the splits in</span>
<span class="sd">        parallel and not in series.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">False</span></div></div>


<div class="viewcode-block" id="SimpleSinkTemplateNode"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.SimpleSinkTemplateNode">[docs]</a><span class="k">class</span> <span class="nc">SimpleSinkTemplateNode</span><span class="p">(</span><span class="n">BaseNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A simple template that illustrates the basic principles of a sink node</span>

<span class="sd">    The sink node is always placed at the end of the node chain. You can think</span>
<span class="sd">    of a sink node as a place in which you can throw all your data and it will</span>
<span class="sd">    do something with this data e.g. saving it to disk.</span>

<span class="sd">    Of course, this is not the only possibility for a Sink node but it is the</span>
<span class="sd">    most basic one. One example of a more complex process happening inside the</span>
<span class="sd">    Sink node is that of the</span>
<span class="sd">    :mod:`~pySPACE.missions.nodes.sink.classification_performance_sink.PerformanceSinkNode`</span>
<span class="sd">    whereby the classification results are collected into a complex structure</span>
<span class="sd">    that reflects the performance of the entire node chain.</span>

<span class="sd">    That being said, this template addresses the very simple case of just</span>
<span class="sd">    collecting the results of the node chain and doing something with them.</span>

<span class="sd">    For a complete list of the available nodes, please consult</span>
<span class="sd">    :mod:`~pySPACE.missions.nodes.sink`</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SimpleSinkTemplateNode.__init__"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.SimpleSinkTemplateNode.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selection_criterion</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Initialize some criterion of selection for the data</span>

<span class="sd">        In the initialization stage, the node is expected to just save some</span>
<span class="sd">        permanent attributes that it might use at a later point in time.</span>
<span class="sd">        In the case of :class:`~pySPACE.resources.data_types.feature_vector.FeatureVector`</span>
<span class="sd">        data, this criterion might represent selected channel names(as</span>
<span class="sd">        implemented in</span>
<span class="sd">        :mod:`~pySPACE.missions.nodes.sink.feature_vector_sink.FeatureVectorSinkNode`</span>
<span class="sd">        while for :mod:`~pySPACE.resources.data_types.time_series.TimeSeries`</span>
<span class="sd">        it might represent a sorting criterion, as implemented in</span>
<span class="sd">        :mod:`~pySPACE.missions.nodes.sink.time_series_sink.TimeSeriesSinkNode`</span>
<span class="sd">        Since this is only a mere template, we will call our selection criterion</span>
<span class="sd">        `selection_criterion` and leave it up to the user to implement specific</span>
<span class="sd">        selection criteria.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SimpleSinkTemplateNode</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_permanent_attributes</span><span class="p">(</span><span class="n">selection_crit</span><span class="o">=</span><span class="n">selection_criterion</span><span class="p">,</span>
                                      <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span></div>

<div class="viewcode-block" id="SimpleSinkTemplateNode.is_trainable"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.SimpleSinkTemplateNode.is_trainable">[docs]</a>    <span class="k">def</span> <span class="nf">is_trainable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return True if the node is trainable</span>

<span class="sd">        While the sink nodes do not need to be trained, they do need access to</span>
<span class="sd">        the training data that is sent through the node chain. In order to</span>
<span class="sd">        achieve this, the :func:`~pySPACE.missions.nodes.base_node.BaseNode.is_trainable`</span>
<span class="sd">        function from the `BaseNode` is overwritten such that it</span>
<span class="sd">        always returns `True` when access to the training data is required.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">True</span></div>

<div class="viewcode-block" id="SimpleSinkTemplateNode.is_supervised"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.SimpleSinkTemplateNode.is_supervised">[docs]</a>    <span class="k">def</span> <span class="nf">is_supervised</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns True if the node requires supervised training</span>

<span class="sd">        The function will almost always return True. If the node requires access</span>
<span class="sd">        to the training data i.e. if the node `is_trainable` it will almost</span>
<span class="sd">        surely also be supervised.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">True</span></div>

<div class="viewcode-block" id="SimpleSinkTemplateNode._train"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.SimpleSinkTemplateNode._train">[docs]</a>    <span class="k">def</span> <span class="nf">_train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Tell the node what to do with specific data inputs</span>

<span class="sd">        In the case of Sink nodes, the `_train` function is usually overwritten</span>
<span class="sd">        with a dummy function that either returns the input data e.g.</span>
<span class="sd">        :mod:`~pySPACE.missions.nodes.sink.analyzer_sink.AnalyzerSinkNode`</span>
<span class="sd">        or just does not(as we will implement it here)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="SimpleSinkTemplateNode.reset"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.SimpleSinkTemplateNode.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Reset the permanent parameters of the node chain</span>

<span class="sd">        When used inside a node chain, the Sink node should also be</span>
<span class="sd">        responsible for saving the permanent state parameters. These</span>
<span class="sd">        parameters get reinitialized whenever the node chain reaches its</span>
<span class="sd">        end. Nevertheless, the parameters should be saved such that they</span>
<span class="sd">        can be inspected after the entire procedure has finished.</span>


<span class="sd">        The following piece of code was adapted from</span>
<span class="sd">        :mod:`~pySPACE.missions.nodes.sink.feature_vector_sink.FeatureVectorSinkNode`</span>
<span class="sd">        with the `FeatureVector` specific parameters changed to dummy</span>
<span class="sd">        variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">copy</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">permanent_state</span>
        <span class="n">tmp</span><span class="p">[</span><span class="s2">&quot;dataset&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">permanent_state</span> <span class="o">=</span> <span class="n">tmp</span></div>

<div class="viewcode-block" id="SimpleSinkTemplateNode.process_current_split"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.SimpleSinkTemplateNode.process_current_split">[docs]</a>    <span class="k">def</span> <span class="nf">process_current_split</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;  The final processing step for the current split</span>

<span class="sd">        This function should contain the last activities that need to be run in</span>
<span class="sd">        the current split. You should include any method that combines, selects</span>
<span class="sd">        or transforms the result data set in any way into this function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="SimpleSinkTemplateNode.get_result_dataset"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.SimpleSinkTemplateNode.get_result_dataset">[docs]</a>    <span class="k">def</span> <span class="nf">get_result_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return the result dataset</span>

<span class="sd">        This function should be built such that it returns the result dataset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">pySPACE documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2016, pySPACE Developer Team.
      Last updated on Sep 04, 2016.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.2.
    </div>
  </body>
</html>